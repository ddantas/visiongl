
/*********************************************************************
***                                                                 ***
***  Source code generated by cl2cpp.pl                             ***
***                                                                 ***
***  Please do not edit                                             ***
***                                                                 ***
*********************************************************************/

#include "vglImage.h"
#include "vglClImage.h"
#include "vglContext.h"

#include "vglShape.h"
#include "vglClShape.h"

#include "vglStrEl.h"
#include "vglClStrEl.h"

#include <fstream>

extern VglClContext cl;

/** N-dimensional dilation

    SHAPE directive passes an array sized 2*VGL_MAX_DIM. Parameter does not appear in wrapper parameter list
    SCALAR directive passes an scalar given by the expression that follows it. Parameter does not appear in wrapper parameter list.
    ARRAY directive passes an array sized as the expression between brackets.
    

typedef 
struct 
VglClShape{ 
  cl_int ndim;
  cl_int shape[11];
  cl_int offset[11];
  cl_int size;
} VglClShape;



  */
void vglClNdDilate(VglImage* img_input, VglImage* img_output, VglStrEl* window){

  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int err;

  cl_mem mobj_shape = NULL;
  mobj_shape = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, sizeof(VglClShape), NULL, &err);
  vglClCheckError( err, (char*) "clCreateBuffer mobj_shape" );
  err = clEnqueueWriteBuffer(cl.commandQueue, mobj_shape, CL_TRUE, 0, sizeof(VglClShape), img_input->vglShape->asVglClShape(), 0, NULL, NULL);
  vglClCheckError( err, (char*) "clEnqueueWriteBuffer mobj_shape" );

  cl_mem mobj_strel = NULL;
  mobj_strel = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, sizeof(VglClStrEl), NULL, &err);
  vglClCheckError( err, (char*) "clCreateBuffer mobj_strel" );
  err = clEnqueueWriteBuffer(cl.commandQueue, mobj_strel, CL_TRUE, 0, sizeof(VglClStrEl), window->asVglClStrEl(), 0, NULL, NULL);
  vglClCheckError( err, (char*) "clEnqueueWriteBuffer mobj_strel" );

  static cl_program program = NULL;
  if (program == NULL)
  {
    char* file_path = (char*) "CL_ND/vglClNdDilate.cl";
    printf("Compiling %s\n", file_path);
    std::ifstream file(file_path);
    if(file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, file_path);
      exit(1);
    }
    std::string prog( std::istreambuf_iterator<char>( file ), ( std::istreambuf_iterator<char>() ) );
    const char *source_str = prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", source_str);
#endif
    program = clCreateProgramWithSource(cl.context, 1, (const char **) &source_str, 0, &err );
    vglClCheckError(err, (char*) "clCreateProgramWithSource" );
    err = clBuildProgram(program, 1, cl.deviceId, "-I CL_ND", NULL, NULL );
    vglClBuildDebug(err, program);
  }

  static cl_kernel kernel = NULL;
  if (kernel == NULL)
  {
    kernel = clCreateKernel( program, "vglClNdDilate", &err ); 
    vglClCheckError(err, (char*) "clCreateKernel" );
  }


  printf("sizeof ( VglClShape ) = %ld\n", sizeof( VglClShape ));
  printf("sizeof ( VglClStrEl ) = %ld\n", sizeof( VglClStrEl ));

  err = clSetKernelArg( kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( err, (char*) "clSetKernelArg 0" );

  printf("CHK 100 \n");
  err = clSetKernelArg( kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( err, (char*) "clSetKernelArg 1" );

  printf("CHK 200 \n");
  err = clSetKernelArg( kernel, 2, sizeof( VglClShape* ), (void*) &mobj_shape );
  vglClCheckError( err, (char*) "clSetKernelArg 2" );

  printf("CHK 300 \n");
  err = clSetKernelArg( kernel, 3, sizeof( VglClStrEl* ), (void*) &mobj_strel );
  vglClCheckError( err, (char*) "clSetKernelArg 3" );

  printf("CHK 400 \n");
  if (img_input->ndim <= 2){
    size_t worksize[] = { img_input->getWidth(), img_input->getHeight(), 1 };
    clEnqueueNDRangeKernel( cl.commandQueue, kernel, 2, NULL, worksize, 0, 0, 0, 0 );
  }
  else if (img_input->ndim == 3){
    size_t worksize[] = { img_input->getWidth(), img_input->getHeight(), img_input->getLength() };
    clEnqueueNDRangeKernel( cl.commandQueue, kernel, 3, NULL, worksize, 0, 0, 0, 0 );
  }
  else{
    printf("More than 3 dimensions not yet supported\n");
  }

  printf("CHK 500 \n");
  vglClCheckError( err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_input, VGL_CL_CONTEXT);

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Direct copy from src to dst.

  */
void vglClNdNot(VglImage* img_input, VglImage* img_output){

  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int err;

  static cl_program program = NULL;
  if (program == NULL)
  {
    char* file_path = (char*) "CL_ND/vglClNdNot.cl";
    printf("Compiling %s\n", file_path);
    std::ifstream file(file_path);
    if(file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, file_path);
      exit(1);
    }
    std::string prog( std::istreambuf_iterator<char>( file ), ( std::istreambuf_iterator<char>() ) );
    const char *source_str = prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", source_str);
#endif
    program = clCreateProgramWithSource(cl.context, 1, (const char **) &source_str, 0, &err );
    vglClCheckError(err, (char*) "clCreateProgramWithSource" );
    err = clBuildProgram(program, 1, cl.deviceId, "-I CL_ND", NULL, NULL );
    vglClBuildDebug(err, program);
  }

  static cl_kernel kernel = NULL;
  if (kernel == NULL)
  {
    kernel = clCreateKernel( program, "vglClNdNot", &err ); 
    vglClCheckError(err, (char*) "clCreateKernel" );
  }


  err = clSetKernelArg( kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( err, (char*) "clSetKernelArg 0" );

  err = clSetKernelArg( kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( err, (char*) "clSetKernelArg 1" );

  if (img_input->ndim <= 2){
    size_t worksize[] = { img_input->getWidth(), img_input->getHeight(), 1 };
    clEnqueueNDRangeKernel( cl.commandQueue, kernel, 2, NULL, worksize, 0, 0, 0, 0 );
  }
  else if (img_input->ndim == 3){
    size_t worksize[] = { img_input->getWidth(), img_input->getHeight(), img_input->getLength() };
    clEnqueueNDRangeKernel( cl.commandQueue, kernel, 3, NULL, worksize, 0, 0, 0, 0 );
  }
  else{
    printf("More than 3 dimensions not yet supported\n");
  }

  vglClCheckError( err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_input, VGL_CL_CONTEXT);

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

