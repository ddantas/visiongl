
/*********************************************************************
***                                                                 ***
***  Source code generated by glsl2cpp.pl                           ***
***                                                                 ***
***  Please do not edit                                             ***
***                                                                 ***
*********************************************************************/

#include "vglImage.h"
#include "vglLoadShader.h"
#include "vglContext.h"

#include <iostream>
/** Calculate absolute difference between img_ref and img_2. Disparities considered are in the closed interval [4*disparity, 4*disparity+3].

    The four differences are stored in the RGBA image dst.

  */
void vglAbsDiffDisparity(VglImage*  img_ref, VglImage*  img_2, VglImage*  dst, float  disparity){

  vglCheckContext(img_ref, VGL_GL_CONTEXT);

  vglCheckContext(img_2, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_Stereo/vglAbsDiffDisparity.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_ref->tex);
  glUniform1i(glGetUniformLocation(_f, "img_ref"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, img_2->tex);
  glUniform1i(glGetUniformLocation(_f, "img_2"),  1);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  img_ref->ipl->width, img_ref->ipl->height);
  glUniform1f(glGetUniformLocation(_f, "disparity"),  disparity);

  glViewport(0, 0, 2*dst->shape[VGL_WIDTH], 2*dst->shape[VGL_HEIGHT]);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE2);
  glDisable(GL_TEXTURE_2D);

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Calculates average absolute difference between img_ref and img_2 at levels of detail in [0, max_lod]. Disparities considered are in the closed interval [4*disparity, 4*disparity+3].

    The four differences are stored in the RGBA image dst.

  */
void vglAbsDiffDisparityMipmap(VglImage*  img_ref, VglImage*  img_2, VglImage*  dst, float  disparity, float  max_lod){

  vglCheckContext(img_ref, VGL_GL_CONTEXT);

  vglCheckContext(img_2, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_Stereo/vglAbsDiffDisparityMipmap.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_ref->tex);
  glUniform1i(glGetUniformLocation(_f, "img_ref"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, img_2->tex);
  glUniform1i(glGetUniformLocation(_f, "img_2"),  1);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  img_ref->ipl->width, img_ref->ipl->height);
  glUniform1f(glGetUniformLocation(_f, "disparity"),  disparity);
  glUniform1f(glGetUniformLocation(_f, "max_lod"),  max_lod);

  glViewport(0, 0, 2*dst->shape[VGL_WIDTH], 2*dst->shape[VGL_HEIGHT]);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE2);
  glDisable(GL_TEXTURE_2D);

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Find best disparity. The first input image, img_dif, contains absolute differences between a pair of images at disparities [4*disparity, 4*disparity+3]. 

    The second input image contains the smallest differences found in channel R, and corresponding disparity value in channel A, Is also an output image, and is updated whenever a smaller difference is found.

  */
void vglFindDisparity(VglImage*  img_dif, VglImage*  img_disp, float  disparity){

  vglCheckContext(img_dif, VGL_GL_CONTEXT);

  vglCheckContext(img_disp, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_Stereo/vglFindDisparity.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_dif->tex);
  glUniform1i(glGetUniformLocation(_f, "img_dif"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, img_disp->tex);
  glUniform1i(glGetUniformLocation(_f, "img_disp"),  1);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, img_disp->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  img_dif->ipl->width, img_dif->ipl->height);
  glUniform1f(glGetUniformLocation(_f, "disparity"),  disparity);

  glViewport(0, 0, 2*img_disp->shape[VGL_WIDTH], 2*img_disp->shape[VGL_HEIGHT]);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (img_disp->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, img_disp->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE2);
  glDisable(GL_TEXTURE_2D);

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(img_disp, VGL_GL_CONTEXT);
}

/** Do the same as vglFindDisparity, but the smallest difference is stored in img_best, and corresponding disparity in img_disp. Both are input and output images.

  */
void vglFindDisparityDiff(VglImage*  img_sum, VglImage*  img_disp, VglImage*  img_best, float  disparity){

  vglCheckContext(img_sum, VGL_GL_CONTEXT);

  vglCheckContext(img_disp, VGL_GL_CONTEXT);

  vglCheckContext(img_best, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_Stereo/vglFindDisparityDiff.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_sum->tex);
  glUniform1i(glGetUniformLocation(_f, "img_sum"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, img_disp->tex);
  glUniform1i(glGetUniformLocation(_f, "img_disp"),  1);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE2);
  glBindTexture(GL_TEXTURE_2D, img_best->tex);
  glUniform1i(glGetUniformLocation(_f, "img_best"),  2);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, img_disp->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT, GL_TEXTURE_2D, img_best->tex, 0);
  CHECK_FRAMEBUFFER_STATUS()

  glPushAttrib(GL_VIEWPORT_BIT | GL_COLOR_BUFFER_BIT);
  GLenum buffers[] = { 
    GL_COLOR_ATTACHMENT0_EXT,
    GL_COLOR_ATTACHMENT1_EXT, };
  glDrawBuffers(2, buffers);
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  img_sum->ipl->width, img_sum->ipl->height);
  glUniform1f(glGetUniformLocation(_f, "disparity"),  disparity);

  glViewport(0, 0, 2*img_disp->shape[VGL_WIDTH], 2*img_disp->shape[VGL_HEIGHT]);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (img_disp->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, img_disp->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  if (img_best->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, img_best->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE3);
  glDisable(GL_TEXTURE_2D);


  glActiveTexture(GL_TEXTURE3);
  glDisable(GL_TEXTURE_2D);

  glPopAttrib();

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(img_disp, VGL_GL_CONTEXT);

  vglSetContext(img_best, VGL_GL_CONTEXT);
}

/** Calculate absolute difference between green channel of img_ref and img_2. Disparities considered are in the closed interval [4*disparity, 4*disparity+3].

    The four differences are stored in the RGBA image dst.

  */
void vglGreenDiffDisparity(VglImage*  img_ref, VglImage*  img_2, VglImage*  dst, float  disparity){

  vglCheckContext(img_ref, VGL_GL_CONTEXT);

  vglCheckContext(img_2, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_Stereo/vglGreenDiffDisparity.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_ref->tex);
  glUniform1i(glGetUniformLocation(_f, "img_ref"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, img_2->tex);
  glUniform1i(glGetUniformLocation(_f, "img_2"),  1);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  img_ref->ipl->width, img_ref->ipl->height);
  glUniform1f(glGetUniformLocation(_f, "disparity"),  disparity);

  glViewport(0, 0, 2*dst->shape[VGL_WIDTH], 2*dst->shape[VGL_HEIGHT]);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE2);
  glDisable(GL_TEXTURE_2D);

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Apply homography in img_src and stores result in img_dst.

    Important: for matrices the cmponents are written in 
    column major order: 

    \c mat2 \c m = \c mat2 (1, 2, 3, 4)
\f$
    \Leftrightarrow
\f$
    \c m = 
\f$
    \left( 
      \begin{array}{cc}
          1  &  3        \\

          2  &  4
      \end{array}
    \right) 

\f$

    In C we build the matrix in line major order, then we must transpose
    tbe matrix before using it in OpenGL context.

  */
void vglHomography(VglImage*  img_src, VglImage*  img_dst, float*  f_homo){

  vglCheckContext(img_src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_Stereo/vglHomography.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_src->tex);
  glUniform1i(glGetUniformLocation(_f, "img_src"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, img_dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  img_src->shape[VGL_WIDTH], img_src->shape[VGL_HEIGHT]);
  glUniformMatrix3fv(glGetUniformLocation(_f, "homo"), 1, 0,  f_homo);

  glViewport(0, 0, 2*img_src->shape[VGL_WIDTH], 2*img_src->shape[VGL_HEIGHT]);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (img_dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, img_dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(img_dst, VGL_GL_CONTEXT);
}

/** Convert depth map to affine reconstruction

    This algorithm ignores the infinite homography.

    img_map: input depth map

    img_3d: output reconstruction

    f: focal length in pixels

    b: baseline in cm

    D: fixation point or maximum depth

    is_float: if true, output image will store z in cm. If false
              output image will store z as 255 * (depth / D). 
              if depth == D then z = 0.

    disp_k: If set, single disparity will be used.

    h: height of camera in cm
 */
void vglMapTo3D(VglImage*  img_map, VglImage*  img_3d, float  f, float  b, float  D, float  disp_k, float  h){

  vglCheckContext(img_map, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_Stereo/vglMapTo3D.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_map->tex);
  glUniform1i(glGetUniformLocation(_f, "img_map"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, img_3d->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "f"),  f);
  glUniform1f(glGetUniformLocation(_f, "b"),  b);
  glUniform1f(glGetUniformLocation(_f, "D"),  D);
  glUniform1f(glGetUniformLocation(_f, "is_float"),  (img_3d->depth == IPL_DEPTH_32F ? 1.0 : 0.0));
  glUniform1f(glGetUniformLocation(_f, "disp_k"),  disp_k);
  glUniform1f(glGetUniformLocation(_f, "h"),  h);
  glUniform1f(glGetUniformLocation(_f, "max_u"),   1.0);
  glUniform1f(glGetUniformLocation(_f, "min_u"),  0.0);
  glUniform1f(glGetUniformLocation(_f, "max_v"),  1.0);
  glUniform1f(glGetUniformLocation(_f, "min_v"),  0.0);
  glUniform1f(glGetUniformLocation(_f, "s_x"),  0.5);
  glUniform1f(glGetUniformLocation(_f, "s_y"),   390.0 / 480.0  /* thiagopx0, 1, ddantas0, 1*/);

  glViewport(0, 0, 2*img_3d->shape[VGL_WIDTH], 2*img_3d->shape[VGL_HEIGHT]);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (img_3d->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, img_3d->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(img_3d, VGL_GL_CONTEXT);
}

/** Mean of pixel values of levels of detail in [0, max_lod]. Result is stored in img_out.


  */
void vglMeanMipmap(VglImage*  img_dif, VglImage*  img_out, float  max_lod){

  vglCheckContext(img_dif, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_Stereo/vglMeanMipmap.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_dif->tex);
  glUniform1i(glGetUniformLocation(_f, "img_dif"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, img_out->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*img_out->shape[VGL_WIDTH], 2*img_out->shape[VGL_HEIGHT]);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (img_out->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, img_out->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(img_out, VGL_GL_CONTEXT);
}

/** Mean filter with a 3x3 square mask.

  */
void vglMeanSq3(VglImage*  img_dif, VglImage*  img_out){

  vglCheckContext(img_dif, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_Stereo/vglMeanSq3.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_dif->tex);
  glUniform1i(glGetUniformLocation(_f, "img_dif"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, img_out->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  img_dif->ipl->width, img_dif->ipl->height);

  glViewport(0, 0, 2*img_out->shape[VGL_WIDTH], 2*img_out->shape[VGL_HEIGHT]);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (img_out->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, img_out->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(img_out, VGL_GL_CONTEXT);
}

/** Undistort, correct projection and rectify img_src and stores result in img_dst, for use with stereo algorithm

    The input float array f_dist contains the coefficient of radial distortion, and f_proj contains the intrinsinc parameters of the camera: center of projection (x and y); focal length in pixels (x and y). The focal lengths are the same when the pixels are square.

    The input float array f_homo contains the homography that rectifies the image.

    Important: for matrices the cmponents are written in 
    column major order: 

    \c mat2 \c m = \c mat2 (1, 2, 3, 4)
\f$
    \Leftrightarrow
\f$
    \c m = 
\f$
    \left( 
      \begin{array}{cc}
          1  &  3        \\

          2  &  4
      \end{array}
    \right) 

\f$


    In C we build the matrix in line major order, then we must transpose
    tbe matrix before using it in OpenGL context.

  */
void vglRectify(VglImage*  img_src, VglImage*  img_dst, float*  f_dist, float*  f_proj, float*  f_homo){

  vglCheckContext(img_src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_Stereo/vglRectify.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_src->tex);
  glUniform1i(glGetUniformLocation(_f, "img_src"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, img_dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  img_src->shape[VGL_WIDTH], img_src->shape[VGL_HEIGHT]);
  glUniform4f(glGetUniformLocation(_f, "dist"),  f_dist[0], f_dist[1], f_dist[2], f_dist[3]);
  glUniform4f(glGetUniformLocation(_f, "proj"),  f_proj[2],  f_proj[5], f_proj[0], f_proj[4]);
  glUniformMatrix3fv(glGetUniformLocation(_f, "homo"), 1, 0,  f_homo);

  glViewport(0, 0, 2*img_dst->shape[VGL_WIDTH], 2*img_dst->shape[VGL_HEIGHT]);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (img_dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, img_dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(img_dst, VGL_GL_CONTEXT);
}

/** VglSumDiff

    Sum of differences

  */
void vglSumDiff(VglImage*  img_dif, VglImage*  img_out){

  vglCheckContext(img_dif, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_Stereo/vglSumDiff.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_dif->tex);
  glUniform1i(glGetUniformLocation(_f, "img_dif"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, img_out->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  img_dif->ipl->width, img_dif->ipl->height);

  glViewport(0, 0, 2*img_out->shape[VGL_WIDTH], 2*img_out->shape[VGL_HEIGHT]);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (img_out->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, img_out->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(img_out, VGL_GL_CONTEXT);
}

/** VglSumDiffMipmap

    Sum of differences

  */
void vglSumDiffMipmap(VglImage*  img_dif, VglImage*  img_out, float  max_lod){

  vglCheckContext(img_dif, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_Stereo/vglSumDiffMipmap.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_dif->tex);
  glUniform1i(glGetUniformLocation(_f, "img_dif"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, img_out->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*img_out->shape[VGL_WIDTH], 2*img_out->shape[VGL_HEIGHT]);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (img_out->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, img_out->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(img_out, VGL_GL_CONTEXT);
}

/** Correct camera lens distortion of img_src and stores the result in img_dst.

    The input float array f_dist contains the coefficient of radial distortion, and f_proj contains the intrinsinc parameters of the camera: center of projection (x and y); focal length in pixels (x and y). The focal lengths are the same when the pixels are square.

    Reference:

    http://www.cognotics.com/opencv/docs/1.0/ref/opencvref_cv.htm#cv_3d

  */
void vglUndistort(VglImage*  img_src, VglImage*  img_dst, float*  f_dist, float*  f_proj){

  vglCheckContext(img_src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_Stereo/vglUndistort.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_src->tex);
  glUniform1i(glGetUniformLocation(_f, "img_src"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, img_dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  img_src->shape[VGL_WIDTH], img_src->shape[VGL_HEIGHT]);
  glUniform4f(glGetUniformLocation(_f, "dist"),  f_dist[0], f_dist[1], f_dist[2], f_dist[3]);
  glUniform4f(glGetUniformLocation(_f, "proj"),  f_proj[2],  f_proj[5], f_proj[0], f_proj[4]);

  glViewport(0, 0, 2*img_dst->shape[VGL_WIDTH], 2*img_dst->shape[VGL_HEIGHT]);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (img_dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, img_dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(img_dst, VGL_GL_CONTEXT);
}

