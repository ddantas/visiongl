
/*********************************************************************
***                                                                 ***
***  Source code generated by glsl2cpp.pl                           ***
***                                                                 ***
***  Please do not edit                                             ***
***                                                                 ***
*********************************************************************/

#include "vglImage.h"
#include "vglLoadShader.h"
#include "vglContext.h"

#include <iostream>

//GL
#include <GL/freeglut_std.h>
#include <GL/freeglut_ext.h>
/** Detects foreground pixels.

  */
void vglDetectFGSimpleBGModel(VglImage*  img_in, VglImage*  average, VglImage*  variance, VglImage*  foreground, float  std_thresh){

  vglCheckContext(img_in, VGL_GL_CONTEXT);

  vglCheckContext(average, VGL_GL_CONTEXT);

  vglCheckContext(variance, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_BG/vglDetectFGSimpleBGModel.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_in->tex);
  glUniform1i(glGetUniformLocation(_f, "img_in"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, average->tex);
  glUniform1i(glGetUniformLocation(_f, "img_avg"),  1);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE2);
  glBindTexture(GL_TEXTURE_2D, variance->tex);
  glUniform1i(glGetUniformLocation(_f, "img_var"),  2);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, foreground->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "std_thresh"), std_thresh);

  glViewport(0, 0, 2*foreground->width, 2*foreground->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (foreground->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, foreground->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE3);
  glDisable(GL_TEXTURE_2D);


  glActiveTexture(GL_TEXTURE3);
  glDisable(GL_TEXTURE_2D);

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(foreground, VGL_GL_CONTEXT);
}

/** Updates average and variance of background model.

  */
void vglTrainSimpleBGModel(VglImage*  img_in, VglImage*  average, VglImage*  variance, float  weight){

  vglCheckContext(img_in, VGL_GL_CONTEXT);

  vglCheckContext(average, VGL_GL_CONTEXT);

  vglCheckContext(variance, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_BG/vglTrainSimpleBGModel.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_in->tex);
  glUniform1i(glGetUniformLocation(_f, "img_in"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, average->tex);
  glUniform1i(glGetUniformLocation(_f, "img_avg"),  1);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE2);
  glBindTexture(GL_TEXTURE_2D, variance->tex);
  glUniform1i(glGetUniformLocation(_f, "img_var"),  2);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, average->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT, GL_TEXTURE_2D, variance->tex, 0);
  CHECK_FRAMEBUFFER_STATUS()

  glPushAttrib(GL_VIEWPORT_BIT | GL_COLOR_BUFFER_BIT);
  GLenum buffers[] = { 
    GL_COLOR_ATTACHMENT0_EXT,
    GL_COLOR_ATTACHMENT1_EXT, };
  glDrawBuffers(2, buffers);
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "weight"), weight);

  glViewport(0, 0, 2*average->width, 2*average->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (average->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, average->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  if (variance->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, variance->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE3);
  glDisable(GL_TEXTURE_2D);


  glActiveTexture(GL_TEXTURE3);
  glDisable(GL_TEXTURE_2D);

  glPopAttrib();

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(average, VGL_GL_CONTEXT);

  vglSetContext(variance, VGL_GL_CONTEXT);
}

/** Updates average and variance of background model only in pixels that are classified as background.

  */
void vglUpdatePartialSimpleBGModel(VglImage*  img_in, VglImage*  foregorundClose, VglImage*  average, VglImage*  variance, float  weight){

  vglCheckContext(img_in, VGL_GL_CONTEXT);

  vglCheckContext(foregorundClose, VGL_GL_CONTEXT);

  vglCheckContext(average, VGL_GL_CONTEXT);

  vglCheckContext(variance, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS_BG/vglUpdatePartialSimpleBGModel.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, img_in->tex);
  glUniform1i(glGetUniformLocation(_f, "img_in"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, foregorundClose->tex);
  glUniform1i(glGetUniformLocation(_f, "img_fg"),  1);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE2);
  glBindTexture(GL_TEXTURE_2D, average->tex);
  glUniform1i(glGetUniformLocation(_f, "img_avg"),  2);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE3);
  glBindTexture(GL_TEXTURE_2D, variance->tex);
  glUniform1i(glGetUniformLocation(_f, "img_var"),  3);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, average->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT, GL_TEXTURE_2D, variance->tex, 0);
  CHECK_FRAMEBUFFER_STATUS()

  glPushAttrib(GL_VIEWPORT_BIT | GL_COLOR_BUFFER_BIT);
  GLenum buffers[] = { 
    GL_COLOR_ATTACHMENT0_EXT,
    GL_COLOR_ATTACHMENT1_EXT, };
  glDrawBuffers(2, buffers);
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "weight"), weight);

  glViewport(0, 0, 2*average->width, 2*average->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (average->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, average->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  if (variance->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, variance->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE4);
  glDisable(GL_TEXTURE_2D);


  glActiveTexture(GL_TEXTURE4);
  glDisable(GL_TEXTURE_2D);


  glActiveTexture(GL_TEXTURE4);
  glDisable(GL_TEXTURE_2D);

  glPopAttrib();

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(average, VGL_GL_CONTEXT);

  vglSetContext(variance, VGL_GL_CONTEXT);
}

