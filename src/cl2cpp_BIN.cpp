
/*********************************************************************
***                                                                 ***
***  Source code generated by cl2cpp.pl                             ***
***                                                                 ***
***  Please do not edit                                             ***
***                                                                 ***
*********************************************************************/

#include "vglImage.h"
#include "vglClImage.h"
#include "vglContext.h"

#include "vglShape.h"
#include "vglClShape.h"

#include "vglStrEl.h"
#include "vglClStrEl.h"

#include <fstream>

extern VglClContext cl;

/** Copy of binary image img_input to img_output.

  */
void vglCl3dBinCopy(VglImage* img_input, VglImage* img_output)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglCl3dBinCopy.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dBinCopy", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Dilation of img_input by mask. Result is stored in img_output.

  */
void vglCl3dBinDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  cl_mem mobj_img_shape = NULL;
  mobj_img_shape = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, sizeof(VglClShape), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer img_shape" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_img_shape, CL_TRUE, 0, sizeof(VglClShape), img_input->vglShape->asVglClShape(), 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer img_shape" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglCl3dBinDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dBinDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  _err = clSetKernelArg( _kernel, 6, sizeof( cl_mem ), (void*) &mobj_img_shape );
  vglClCheckError( _err, (char*) "clSetKernelArg 6" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  _err = clReleaseMemObject( mobj_img_shape );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_img_shape");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Dilation of img_input by mask. Result is stored in img_output.

  */
void vglCl3dBinErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  cl_mem mobj_img_shape = NULL;
  mobj_img_shape = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, sizeof(VglClShape), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer img_shape" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_img_shape, CL_TRUE, 0, sizeof(VglClShape), img_input->vglShape->asVglClShape(), 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer img_shape" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglCl3dBinErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dBinErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  _err = clSetKernelArg( _kernel, 6, sizeof( cl_mem ), (void*) &mobj_img_shape );
  vglClCheckError( _err, (char*) "clSetKernelArg 6" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  _err = clReleaseMemObject( mobj_img_shape );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_img_shape");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Maximum or union between two images.

    Maximum or union between img_input1 and img_input2. Result save in img_output.
  */
void vglCl3dBinMax(VglImage* img_input1, VglImage* img_input2, VglImage* img_output)
{
  vglCheckContext(img_input1, VGL_CL_CONTEXT);
  vglCheckContext(img_input2, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglCl3dBinMax.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dBinMax", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input1->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_input2->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  int _ndim = 2;
  if (img_input1->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input1->getWidthIn();
  if (img_input1->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input1->getWidthStep();
  }
  if (img_input2->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input2->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input1->getHeightIn(),  img_input1->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Minimum or intersection between two images.

    Minimum or intersection between img_input1 and img_input2. Result saved in img_output.
  */
void vglCl3dBinMin(VglImage* img_input1, VglImage* img_input2, VglImage* img_output)
{
  vglCheckContext(img_input1, VGL_CL_CONTEXT);
  vglCheckContext(img_input2, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglCl3dBinMin.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dBinMin", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input1->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_input2->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  int _ndim = 2;
  if (img_input1->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input1->getWidthIn();
  if (img_input1->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input1->getWidthStep();
  }
  if (img_input2->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input2->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input1->getHeightIn(),  img_input1->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Negation of binary image img_input. Result is stored in img_output.

  */
void vglCl3dBinNot(VglImage* img_input, VglImage* img_output)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglCl3dBinNot.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dBinNot", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Generate ROI.

    Generate ROI (Region Of Interest). Useful to be used as mask to do intersection
    with other images.

  */
void vglCl3dBinRoi(VglImage* img_output, int x0, int y0, int z0, int xf, int yf, int zf)
{
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglCl3dBinRoi.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dBinRoi", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( int ), &x0 );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( int ), &y0 );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &z0 );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &xf );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &yf );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  _err = clSetKernelArg( _kernel, 6, sizeof( int ), &zf );
  vglClCheckError( _err, (char*) "clSetKernelArg 6" );

  int _ndim = 2;
  if (img_output->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_output->getWidthIn();
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_output->getHeightIn(),  img_output->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Subtraction or difference between two binary images.

    Subtraction or difference between two binary images. Finds img_input1 minus img_input2 and
    saves in img_output.
  */
void vglCl3dBinSub(VglImage* img_input1, VglImage* img_input2, VglImage* img_output)
{
  vglCheckContext(img_input1, VGL_CL_CONTEXT);
  vglCheckContext(img_input2, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglCl3dBinSub.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dBinSub", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input1->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_input2->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  int _ndim = 2;
  if (img_input1->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input1->getWidthIn();
  if (img_input1->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input1->getWidthStep();
  }
  if (img_input2->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input2->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input1->getHeightIn(),  img_input1->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Threshold of grayscale image with binary result.

    Threshold of grayscale image img_input. Result is binary, stored in img_output. Parameter
    thresh is float between 0.0 and 1.0.
  */
void vglCl3dBinThreshold(VglImage* img_input, VglImage* img_output, float thresh)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglCl3dBinThreshold.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dBinThreshold", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( float ), &thresh );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Convert binary image to grayscale.

    Convert binary image to grayscale.
  */
void vglCl3dBinToGray(VglImage* img_input, VglImage* img_output)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglCl3dBinToGray.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dBinToGray", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Conway game of life.

  */
void vglClBinConway(VglImage* img_input, VglImage* img_output)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_img_shape = NULL;
  mobj_img_shape = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, sizeof(VglClShape), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer img_shape" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_img_shape, CL_TRUE, 0, sizeof(VglClShape), img_input->vglShape->asVglClShape(), 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer img_shape" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClBinConway.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClBinConway", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (void*) &mobj_img_shape );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_img_shape );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_img_shape");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Copy of binary image img_input to img_output.

  */
void vglClBinCopy(VglImage* img_input, VglImage* img_output)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClBinCopy.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClBinCopy", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Dilation of img_input by mask. Result is stored in img_output.

  */
void vglClBinDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  cl_mem mobj_img_shape = NULL;
  mobj_img_shape = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, sizeof(VglClShape), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer img_shape" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_img_shape, CL_TRUE, 0, sizeof(VglClShape), img_input->vglShape->asVglClShape(), 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer img_shape" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClBinDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClBinDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( cl_mem ), (void*) &mobj_img_shape );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  _err = clReleaseMemObject( mobj_img_shape );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_img_shape");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of img_input by mask. Result is stored in img_output.

  */
void vglClBinErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  cl_mem mobj_img_shape = NULL;
  mobj_img_shape = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, sizeof(VglClShape), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer img_shape" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_img_shape, CL_TRUE, 0, sizeof(VglClShape), img_input->vglShape->asVglClShape(), 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer img_shape" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClBinErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClBinErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( cl_mem ), (void*) &mobj_img_shape );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  _err = clReleaseMemObject( mobj_img_shape );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_img_shape");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Maximum or union between two images.

    Maximum or union between img_input1 and img_input2. Result saved in img_output.
  */
void vglClBinMax(VglImage* img_input1, VglImage* img_input2, VglImage* img_output)
{
  vglCheckContext(img_input1, VGL_CL_CONTEXT);
  vglCheckContext(img_input2, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClBinMax.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClBinMax", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input1->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_input2->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  int _ndim = 2;
  if (img_input1->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input1->getWidthIn();
  if (img_input1->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input1->getWidthStep();
  }
  if (img_input2->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input2->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input1->getHeightIn(),  img_input1->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Minimum or intersection between two images.

    Minimum or intersection between img_input1 and img_input2. Result saved in img_output.
  */
void vglClBinMin(VglImage* img_input1, VglImage* img_input2, VglImage* img_output)
{
  vglCheckContext(img_input1, VGL_CL_CONTEXT);
  vglCheckContext(img_input2, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClBinMin.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClBinMin", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input1->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_input2->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  int _ndim = 2;
  if (img_input1->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input1->getWidthIn();
  if (img_input1->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input1->getWidthStep();
  }
  if (img_input2->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input2->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input1->getHeightIn(),  img_input1->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Negation of binary image img_input. Result is stored in img_output.

  */
void vglClBinNot(VglImage* img_input, VglImage* img_output)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClBinNot.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClBinNot", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Generate ROI.

    Generate ROI (Region Of Interest). Useful to be used as mask to do intersection
    with other images.

  */
void vglClBinRoi(VglImage* img_output, int x0, int y0, int xf, int yf)
{
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClBinRoi.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClBinRoi", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( int ), &x0 );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( int ), &y0 );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &xf );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &yf );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  int _ndim = 2;
  if (img_output->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_output->getWidthIn();
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_output->getHeightIn(),  img_output->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Subtraction or difference between two binary images.

    Subtraction or difference between two binary images. Finds img_input1 minus img_input2 and
    saves in img_output.
  */
void vglClBinSub(VglImage* img_input1, VglImage* img_input2, VglImage* img_output)
{
  vglCheckContext(img_input1, VGL_CL_CONTEXT);
  vglCheckContext(img_input2, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClBinSub.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClBinSub", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input1->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_input2->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  int _ndim = 2;
  if (img_input1->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input1->getWidthIn();
  if (img_input1->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input1->getWidthStep();
  }
  if (img_input2->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input2->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input1->getHeightIn(),  img_input1->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Threshold of grayscale image with binary result.

    Threshold of grayscale image img_input. Result is binary, stored in img_output. Parameter
    thresh is float between 0.0 and 1.0.
  */
void vglClBinThreshold(VglImage* img_input, VglImage* img_output, float thresh)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClBinThreshold.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClBinThreshold", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( float ), &thresh );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Convert binary image to grayscale.

    Convert binary image to grayscale.
  */
void vglClBinToGray(VglImage* img_input, VglImage* img_output)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClBinToGray.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClBinToGray", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** N-dimensional dilation

    SHAPE directive passes a structure with size of each dimension, offsets and number of dimensions. Parameter does not appear in wrapper parameter list. The C expression between parenthesis returns the desired shape of type VglClShape.
    
  */
void vglClNdBinDilate(VglImage* img_input, VglImage* img_output, VglStrEl* window)
{
  if (  ( (img_input->ndim == 2) || (img_input->ndim == 3) )  &&  !(img_input->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_input.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  if (  ( (img_output->ndim == 2) || (img_output->ndim == 3) )  &&  !(img_output->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_output.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_img_shape = NULL;
  mobj_img_shape = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, sizeof(VglClShape), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer img_shape" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_img_shape, CL_TRUE, 0, sizeof(VglClShape), img_input->vglShape->asVglClShape(), 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer img_shape" );

  cl_mem mobj_window = NULL;
  mobj_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, sizeof(VglClStrEl), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_window, CL_TRUE, 0, sizeof(VglClStrEl), window->asVglClStrEl(), 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClNdBinDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClNdBinDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (void*) &mobj_img_shape );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( cl_mem ), (void*) &mobj_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_img_shape );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_img_shape");

  _err = clReleaseMemObject( mobj_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_window");

  vglSetContext(img_input, VGL_CL_CONTEXT);

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Maximum or union between two images.

    Maximum or union between img_input1 and img_input2. Result saved in img_output.
  */
void vglClNdBinMax(VglImage* img_input1, VglImage* img_input2, VglImage* img_output)
{
  if (  ( (img_input1->ndim == 2) || (img_input1->ndim == 3) )  &&  !(img_input1->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_input1.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  if (  ( (img_input2->ndim == 2) || (img_input2->ndim == 3) )  &&  !(img_input2->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_input2.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  if (  ( (img_output->ndim == 2) || (img_output->ndim == 3) )  &&  !(img_output->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_output.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  vglCheckContext(img_input1, VGL_CL_CONTEXT);
  vglCheckContext(img_input2, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClNdBinMax.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClNdBinMax", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input1->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_input2->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  int _ndim = 2;
  if (img_input1->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input1->getWidthIn();
  if (img_input1->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input1->getWidthStep();
  }
  if (img_input2->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input2->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input1->getHeightIn(),  img_input1->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_input1, VGL_CL_CONTEXT);

  vglSetContext(img_input2, VGL_CL_CONTEXT);

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Minimum or intersection between two images.

    Minimum or intersection between img_input1 and img_input2. Result saved in img_output.
  */
void vglClNdBinMin(VglImage* img_input1, VglImage* img_input2, VglImage* img_output)
{
  if (  ( (img_input1->ndim == 2) || (img_input1->ndim == 3) )  &&  !(img_input1->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_input1.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  if (  ( (img_input2->ndim == 2) || (img_input2->ndim == 3) )  &&  !(img_input2->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_input2.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  if (  ( (img_output->ndim == 2) || (img_output->ndim == 3) )  &&  !(img_output->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_output.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  vglCheckContext(img_input1, VGL_CL_CONTEXT);
  vglCheckContext(img_input2, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClNdBinMin.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClNdBinMin", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input1->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_input2->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  int _ndim = 2;
  if (img_input1->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input1->getWidthIn();
  if (img_input1->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input1->getWidthStep();
  }
  if (img_input2->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input2->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input1->getHeightIn(),  img_input1->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_input1, VGL_CL_CONTEXT);

  vglSetContext(img_input2, VGL_CL_CONTEXT);

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Negation of binary image img_input. Result is stored in img_output.

  */
void vglClNdBinNot(VglImage* img_input, VglImage* img_output)
{
  if (  ( (img_input->ndim == 2) || (img_input->ndim == 3) )  &&  !(img_input->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_input.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  if (  ( (img_output->ndim == 2) || (img_output->ndim == 3) )  &&  !(img_output->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_output.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClNdBinNot.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClNdBinNot", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_input, VGL_CL_CONTEXT);

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Generate ROI.

    Generate ROI (Region Of Interest). Useful to be used as mask to do intersection
    with other images.

  */
void vglClNdBinRoi(VglImage* img_output, int* p0, int* pf)
{
  if (  ( (img_output->ndim == 2) || (img_output->ndim == 3) )  &&  !(img_output->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_output.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_p0 = NULL;
  mobj_p0 = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (VGL_ARR_SHAPE_SIZE)*sizeof(int), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer p0" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_p0, CL_TRUE, 0, (VGL_ARR_SHAPE_SIZE)*sizeof(int), p0, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer p0" );

  cl_mem mobj_pf = NULL;
  mobj_pf = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (VGL_ARR_SHAPE_SIZE)*sizeof(int), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer pf" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_pf, CL_TRUE, 0, (VGL_ARR_SHAPE_SIZE)*sizeof(int), pf, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer pf" );

  cl_mem mobj_img_shape = NULL;
  mobj_img_shape = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, sizeof(VglClShape), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer img_shape" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_img_shape, CL_TRUE, 0, sizeof(VglClShape), img_output->vglShape->asVglClShape(), 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer img_shape" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClNdBinRoi.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClNdBinRoi", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (int*) &mobj_p0 );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (int*) &mobj_pf );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( cl_mem ), (void*) &mobj_img_shape );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  int _ndim = 2;
  if (img_output->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_output->getWidthIn();
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_output->getHeightIn(),  img_output->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_p0 );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_p0");

  _err = clReleaseMemObject( mobj_pf );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_pf");

  _err = clReleaseMemObject( mobj_img_shape );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_img_shape");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Subtraction or difference between two binary images.

    Subtraction or difference between two binary images. Finds img_input1 minus img_input2 and
    saves in img_output.
  */
void vglClNdBinSub(VglImage* img_input1, VglImage* img_input2, VglImage* img_output)
{
  if (  ( (img_input1->ndim == 2) || (img_input1->ndim == 3) )  &&  !(img_input1->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_input1.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  if (  ( (img_input2->ndim == 2) || (img_input2->ndim == 3) )  &&  !(img_input2->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_input2.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  if (  ( (img_output->ndim == 2) || (img_output->ndim == 3) )  &&  !(img_output->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_output.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  vglCheckContext(img_input1, VGL_CL_CONTEXT);
  vglCheckContext(img_input2, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClNdBinSub.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClNdBinSub", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input1->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_input2->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  int _ndim = 2;
  if (img_input1->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input1->getWidthIn();
  if (img_input1->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input1->getWidthStep();
  }
  if (img_input2->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input2->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input1->getHeightIn(),  img_input1->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  vglSetContext(img_input1, VGL_CL_CONTEXT);

  vglSetContext(img_input2, VGL_CL_CONTEXT);

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Threshold of img_input by parameter. if the pixel is below thresh,
    the output is 0, else, the output is 1. Result is stored in img_output.
    Input image is 8bpp and output is 1bpp.
  */
void vglClNdBinThreshold(VglImage* img_input, VglImage* img_output, unsigned char thresh)
{
  if (  ( (img_input->ndim == 2) || (img_input->ndim == 3) )  &&  !(img_input->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_input.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  if (  ( (img_output->ndim == 2) || (img_output->ndim == 3) )  &&  !(img_output->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_output.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_in_shape = NULL;
  mobj_in_shape = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, sizeof(VglClShape), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer in_shape" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_in_shape, CL_TRUE, 0, sizeof(VglClShape), img_input->vglShape->asVglClShape(), 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer in_shape" );

  cl_mem mobj_out_shape = NULL;
  mobj_out_shape = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, sizeof(VglClShape), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer out_shape" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_out_shape, CL_TRUE, 0, sizeof(VglClShape), img_output->vglShape->asVglClShape(), 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer out_shape" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClNdBinThreshold.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClNdBinThreshold", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( unsigned char ), &thresh );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( cl_mem ), (void*) &mobj_in_shape );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( cl_mem ), (void*) &mobj_out_shape );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_in_shape );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_in_shape");

  _err = clReleaseMemObject( mobj_out_shape );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_out_shape");

  vglSetContext(img_input, VGL_CL_CONTEXT);

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Convert binary image to grayscale.

    Convert binary image to grayscale.
  */
void vglClNdBinToGray(VglImage* img_input, VglImage* img_output)
{
  if (  ( (img_input->ndim == 2) || (img_input->ndim == 3) )  &&  !(img_input->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_input.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  if (  ( (img_output->ndim == 2) || (img_output->ndim == 3) )  &&  !(img_output->clForceAsBuf)  )
  {
    fprintf(stderr, "%s: %s: Error: this function supports only OpenCL data as buffer. Please call vglClForceAsBuf() just after creating img_output.\n", __FILE__, __FUNCTION__);
    exit(1);
  }
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_in_shape = NULL;
  mobj_in_shape = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, sizeof(VglClShape), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer in_shape" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_in_shape, CL_TRUE, 0, sizeof(VglClShape), img_input->vglShape->asVglClShape(), 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer in_shape" );

  cl_mem mobj_out_shape = NULL;
  mobj_out_shape = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, sizeof(VglClShape), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer out_shape" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_out_shape, CL_TRUE, 0, sizeof(VglClShape), img_output->vglShape->asVglClShape(), 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer out_shape" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_BIN/vglClNdBinToGray.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_BIN/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClNdBinToGray", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (void*) &mobj_in_shape );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( cl_mem ), (void*) &mobj_out_shape );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_in_shape );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_in_shape");

  _err = clReleaseMemObject( mobj_out_shape );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_out_shape");

  vglSetContext(img_input, VGL_CL_CONTEXT);

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

