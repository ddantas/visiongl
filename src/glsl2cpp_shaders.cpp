
/*********************************************************************
***                                                                 ***
***  Source code generated by glsl2cpp.pl                           ***
***                                                                 ***
***  Please do not edit                                             ***
***                                                                 ***
*********************************************************************/

#include "vglImage.h"
#include "vglLoadShader.h"
#include "vglContext.h"

#include <iostream>

void shader_15_1(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/shader_15_1.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);
  glUniform1f(glGetUniformLocation(_f, "width"),  src->ipl->width);
  glUniform1f(glGetUniformLocation(_f, "height"),  src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Convert grayscale image to RGB

  */
void vgl1to3Channels(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vgl1to3Channels.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1i(glGetUniformLocation(_f, "width"),  src->width);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Absolute difference between two images.

  */
void vglAbsDiff(VglImage*  src0, VglImage*  src1, VglImage*  dst){

  vglCheckContext(src0, VGL_GL_CONTEXT);

  vglCheckContext(src1, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglAbsDiff.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src0->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, src1->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler1"),  1);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE2);
  glDisable(GL_TEXTURE_2D);

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Logical AND between two images

  */
void vglAnd(VglImage*  src0, VglImage*  src1, VglImage*  dst){

  vglCheckContext(src0, VGL_GL_CONTEXT);

  vglCheckContext(src1, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglAnd.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src0->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, src1->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler1"),  1);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE2);
  glDisable(GL_TEXTURE_2D);

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Initialize image to be used in baricenter calculation. The initialization is done by storing the values (1, x, y) in each output pixel so that the summation over th whole image gives the three moments of the image.

    R =                    f(x, y) 

    G =                x * f(x, y) 

    B =                y * f(x, y) 

  */
void vglBaricenterInit(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglBaricenterInit.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** vglBlurSq3

    Blur image by 3x3 square structuring element.

  */
void vglBlurSq3(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglBlurSq3.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Clear image with given color.

  */
void vglClear2(VglImage*  src_dst, float  r, float  g, float  b, float  a){

  vglCheckContext(src_dst, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglClear2.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src_dst->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, src_dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "r"), r);
  glUniform1f(glGetUniformLocation(_f, "g"), g);
  glUniform1f(glGetUniformLocation(_f, "b"), b);
  glUniform1f(glGetUniformLocation(_f, "a"), a);

  glViewport(0, 0, 2*src_dst->width, 2*src_dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (src_dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, src_dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(src_dst, VGL_GL_CONTEXT);
}

/** Changes contrast of image by given factor.

  */
void vglContrast(VglImage*  src, VglImage*  dst, float  factor){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglContrast.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "factor"),  factor);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Shows coordinates of pixels as colors. Red is horizontal and green is vertical. Coordinates and colors are defined by OpenGL, that is, between 0 and 1.

  */
void vglCoordToColor(VglImage*  dst){

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglCoordToColor.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Direct copy from src to dst.

  */
void vglCopy(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglCopy.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Crossing number is defined as the number of ocurrences of the pattern 01
in the neihborhood of a pixel.

    Neighborhood of pixel P is indexed as follows:

\f$
\begin{array}{ccc}

    P3   &  P2   &  P1      \\ 
    P4   &  P    &  P0/8    \\
    P5   &  P6   &  P7

\end{array}
\f$


    References:

    M. Couprie, Note on fifteen 2D parallel thinning algorithms, 2006

    T. M. Bernard and A. Manzanera, Improved low complexity fully parallel
        thinning algorithms, 1999

  */
void vglCrossingNumber(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglCrossingNumber.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "src"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Deletes corner from skeleton.

    Receive as input the image with the skeleton to be thinned. Receives 
    also the step. must be called once with step 1 and once with step 2.

    Neighborhood pixels is indexed as follows:

\f$
\begin{array}{ccc}

    P3  &  P2  &  P1      \\
    P4  &  P8  &  P0      \\
    P5  &  P6  &  P7

\end{array}
\f$


    Pixels deleted are the ones that mach the pattern and its rotations 
    by 90deg.

\f$
\begin{array}{ccc}

    0  &  0  &  x      \\
    0  &  1  &  1      \\
    x  &  1  &  0

\end{array}
\f$

    References:

    M. Couprie, Note on fifteen 2D parallel thinning algorithms, 2006

    T. M. Bernard and A. Manzanera, Improved low complexity fully parallel
        thinning algorithms, 1999

  */
void vglDeleteSkeletonCorners(VglImage*  src, VglImage*  dst, int  step){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglDeleteSkeletonCorners.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "src"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1i(glGetUniformLocation(_f, "step"),  step);
  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Deletes warts from skeleton. Receive as input the image with the skeleton to be thinned. Neighborhood pixels are indexed as follows:

\f$
\begin{array}{ccc}

    P3  &  P2  &  P1      \\
    P4  &  P   &  P0/8    \\
    P5  &  P6  &  P7

\end{array}
\f$

    Pixels deleted are the ones that mach the pattern and its rotations 
    by 45deg.

\f$
\begin{array}{ccc}

    1  &  0  &  0    \\
    1  &  1  &  0    \\
    1  &  0  &  0

\end{array}
\f$

    That is the same as delete the pixels with crossing number = 1 and 
neighbor number = 3

    References:

    Ke Liu et al., Identification of fork points on the skeletons
        of handwritten chinese characters

  */
void vglDeleteSkeletonWarts(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglDeleteSkeletonWarts.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "src"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Deletes warts from skeleton. Receive as input the image with the skeleton to be thinned. Neighborhood pixels are indexed as follows:

    P3 P2 P1

    P4 P  P0/8

    P5 P6 P7

    Pixels deleted are the ones that mach the pattern and its rotations 
    by 45deg.

    1 0 0
    1 1 0
    1 0 0

    1 1 0
    1 1 0
    1 0 0

    1 1 0
    1 1 0
    1 1 0

    1 1 1
    1 1 0
    1 1 0

    1 1 1
    1 1 0
    1 1 1


    That is the same as delete the pixels with crossing number = 1 and 
neighbor number >=3

    References:

    Ke Liu et al., Identification of fork points on the skeletons
        of handwritten chinese characters

  */
void vglDeleteSkeletonWarts2(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglDeleteSkeletonWarts2.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "src"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Image src0 minus src1.

  */
void vglDiff(VglImage*  src0, VglImage*  src1, VglImage*  dst){

  vglCheckContext(src0, VGL_GL_CONTEXT);

  vglCheckContext(src1, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglDiff.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src0->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, src1->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler1"),  1);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE2);
  glDisable(GL_TEXTURE_2D);

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Dilation of image by 3x3 cross structuring element.

  */
void vglDilateCross3(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglDilateCross3.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Dilation of image by 3x3 square structuring element.

  */
void vglDilateSq3(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglDilateSq3.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Erosion of image by 3x3 cross structuring element.

  */
void vglErodeCross3(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglErodeCross3.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Erosion of image by horizontal line with 3 pixels.

  */
void vglErodeHL3(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglErodeHL3.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Erosion of image by horizontal line with 5 pixels.

  */
void vglErodeHL5(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglErodeHL5.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Erosion of image by horizontal line with 7 pixels.

  */
void vglErodeHL7(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglErodeHL7.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Erosion of image by 3x3 square structuring element.

  */
void vglErodeSq3(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglErodeSq3.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Erosion of image by 3x3 square structuring element. Uses an offset array with 9 elements. Slower than vglErodeSq3.

  */
void vglErodeSq3off(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglErodeSq3off.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Erosion of image by 5x5 square structuring element.

  */
void vglErodeSq5(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglErodeSq5.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Erosion of image by 3x3 square structuring element. Uses an offset array with 25 elements. Slower than vglErodeSq5.

  */
void vglErodeSq5off(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglErodeSq5off.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Erosion of image by 7x7 square structuring element.

  */
void vglErodeSq7(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglErodeSq7.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Erosion of image by square structuring element. The parameter "side" is the dimension of the square side in pixels.

  */
void vglErodeSqSide(VglImage*  src, VglImage*  dst, int  side){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglErodeSqSide.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);
  glUniform1i(glGetUniformLocation(_f, "radius"),  (side - 1) / 2);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Erosion of image by vertical line with 3 pixels.

  */
void vglErodeVL3(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglErodeVL3.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Erosion of image by vertical line with 5 pixels.

  */
void vglErodeVL5(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglErodeVL5.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Erosion of image by vertical line with 7 pixels.

  */
void vglErodeVL7(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglErodeVL7.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Feature Points are defined as function of the crossing number
and number of neighbors of a pixel. 

The number of neighbors is indicated as Nb. Crossing number is defined as

Nc = number of occurrences of the pattern 01 in the neighborhood of P

    Neighborhood pixels are indexed as follows:

    P3 P2 P1

    P4 P  P0

    P5 P6 P7


    All the ending points are feature points. Are defined as
Se = { P | Nc(P) = 1 }


    Feature points type 1, denoted as S1, are defined as
S1 = { P | Nc(P) >= 3}

    Feature points type 2, denoted as S2, are defined as
S1 = { P | Nb(P) >= 3}

    Feature points type 3, denoted as S3, are defined as
S3 = { P | Nc(P) >= 3 or Nb(P) >= 4 }


    References:

    Ke Liu et al., Identification of fork points on the skeletons
        of handwritten chinese characters

  */
void vglFeaturePoints(VglImage*  src, VglImage*  dst, int  type){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglFeaturePoints.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "src"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1i(glGetUniformLocation(_f, "type"),  type);
  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Blurs image by 3x3 square gaussian structuring element.

  */
void vglGaussianBlurSq3(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglGaussianBlurSq3.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Convert image to grayscale by calculating the scalar product of (r, g, b) and (.2125, .7154, .0721).

  */
void vglGray(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglGray.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Flip image horizontally i.e. left becomes right.

    Image flip done by shader.
  */
void vglHorizontalFlip(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglHorizontalFlip.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** vglInOut

    Test and model for IN_OUT semantics

  */
void vglInOut(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglInOut.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, src->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT, GL_TEXTURE_2D, dst->tex, 0);
  CHECK_FRAMEBUFFER_STATUS()

  glPushAttrib(GL_VIEWPORT_BIT | GL_COLOR_BUFFER_BIT);
  GLenum buffers[] = { 
    GL_COLOR_ATTACHMENT0_EXT,
    GL_COLOR_ATTACHMENT1_EXT, };
  glDrawBuffers(2, buffers);
  ERRCHECK()


  glViewport(0, 0, 2*src->width, 2*src->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (src->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, src->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glPopAttrib();

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(src, VGL_GL_CONTEXT);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Calculate Julia set

  */
void vglJulia(VglImage*  dst, float  ox, float  oy, float  half_win, float  c_real, float  c_imag){

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglJulia.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "ox"),  ox);
  glUniform1f(glGetUniformLocation(_f, "oy"),  oy);
  glUniform1f(glGetUniformLocation(_f, "half_win"),  half_win);
  glUniform1f(glGetUniformLocation(_f, "c_real"),  c_real);
  glUniform1f(glGetUniformLocation(_f, "c_imag"),  c_imag);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Laplacian of image by 3x3 square structuring element.

  */
void vglLaplaceSq3(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglLaplaceSq3.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Calculate Mandelbrot set

  */
void vglMandel(VglImage*  dst, float  ox, float  oy, float  half_win){

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglMandel.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "ox"),  ox);
  glUniform1f(glGetUniformLocation(_f, "oy"),  oy);
  glUniform1f(glGetUniformLocation(_f, "half_win"),  half_win);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Get specified level of detail.

  */
void vglMipmap(VglImage*  src, VglImage*  dst, float  lod){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglMipmap.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "lod"),  lod);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Multiply image by scalar.

  */
void vglMulScalar(VglImage*  src, VglImage*  dst, float  factor){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglMulScalar.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "factor"), factor);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** VglAdd

    Sum of two images.

  */
void vglMultiInput(VglImage*  src0, VglImage*  src1, VglImage*  dst, float  weight){

  vglCheckContext(src0, VGL_GL_CONTEXT);

  vglCheckContext(src1, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglMultiInput.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src0->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, src1->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler1"),  1);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "weight"), weight);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE2);
  glDisable(GL_TEXTURE_2D);

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** vglGray

    Convert image to grayscale

  */
void vglMultiOutput(VglImage*  src, VglImage*  dst, VglImage*  dst1){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglMultiOutput.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT, GL_TEXTURE_2D, dst1->tex, 0);
  CHECK_FRAMEBUFFER_STATUS()

  glPushAttrib(GL_VIEWPORT_BIT | GL_COLOR_BUFFER_BIT);
  GLenum buffers[] = { 
    GL_COLOR_ATTACHMENT0_EXT,
    GL_COLOR_ATTACHMENT1_EXT, };
  glDrawBuffers(2, buffers);
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  if (dst1->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst1->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glPopAttrib();

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);

  vglSetContext(dst1, VGL_GL_CONTEXT);
}

/** Add gaussian noise to image

  */
void vglNoise(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglNoise.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Inverts image.

  */
void vglNot(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglNot.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Logical OR between two images

  */
void vglOr(VglImage*  src0, VglImage*  src1, VglImage*  dst){

  vglCheckContext(src0, VGL_GL_CONTEXT);

  vglCheckContext(src1, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglOr.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src0->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, src1->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler1"),  1);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE2);
  glDisable(GL_TEXTURE_2D);

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Rescales corners of image to given corners

  */
void vglRescale(VglImage*  src, VglImage*  dst, float  x0, float  y0, float  x1, float  y1){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglRescale.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "src"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "x_0"),  x0 / (float)src->width);
  glUniform1f(glGetUniformLocation(_f, "y_0"),  y0 / (float)src->height);
  glUniform1f(glGetUniformLocation(_f, "x_1"),  x1 / (float)src->width);
  glUniform1f(glGetUniformLocation(_f, "y_1"),  y1 / (float)src->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Converts image RGB to BGR color space

  */
void vglRgbToBgr(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglRgbToBgr.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Converts image RGB to HSL color space

  */
void vglRgbToHsl(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglRgbToHsl.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Converts image RGB to HSV color space

  */
void vglRgbToHsv(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglRgbToHsv.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Converts image RGB to XYZ color space.

  */
void vglRgbToXyz(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglRgbToXyz.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Roberts gradient of image

  */
void vglRobertsGradient(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglRobertsGradient.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Stores in output pixel the sum of 4 adjacent pixels of the input
    image. 
    The width and height of the output image must be half of the input image.

  */
void vglSelfSum22(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglSelfSum22.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Stores in output pixel the sum of 3 adjacent pixels of the input
    image. 
    The height of the output image must be 1/3th of the input image.

  */
void vglSelfSum3v(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglSelfSum3v.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Stores in output pixel the sum of 4 adjacent pixels of the input
    image. 
    The width of the output image must be 1/4th of the input image.

  */
void vglSelfSum4h(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglSelfSum4h.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Stores in output pixel the sum of 5 adjacent pixels of the input
    image. 
    The width of the output image must be 1/5th of the input image.

  */
void vglSelfSum5h(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglSelfSum5h.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Stores in output pixel the sum of 5 adjacent pixels of the input
    image. 
    The height of the output image must be 1/5th of the input image.

  */
void vglSelfSum5v(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglSelfSum5v.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Sharpens image using 3x3 square window.

  */
void vglSharpenSq3(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglSharpenSq3.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Sobel gradient of image

  */
void vglSobelGradient(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglSobelGradient.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Sobel edge filtering in X direction.

  */
void vglSobelXSq3(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglSobelXSq3.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Sobel edge filtering in Y direction.

  */
void vglSobelYSq3(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglSobelYSq3.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Sum of two images.

  */
void vglSum(VglImage*  src0, VglImage*  src1, VglImage*  dst){

  vglCheckContext(src0, VGL_GL_CONTEXT);

  vglCheckContext(src1, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglSum.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src0->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, src1->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler1"),  1);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE2);
  glDisable(GL_TEXTURE_2D);

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Weighted sum of two images. The first image is multiplied by weight, and the second, by 1 - weight. Default weight is 0.5.

  */
void vglSumWeighted(VglImage*  src0, VglImage*  src1, VglImage*  dst, float  weight){

  vglCheckContext(src0, VGL_GL_CONTEXT);

  vglCheckContext(src1, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglSumWeighted.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src0->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, src1->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler1"),  1);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "weight"), weight);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE2);
  glDisable(GL_TEXTURE_2D);

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Convert image from RGB to BGR and vice versa.

  */
void vglSwapRGB(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglSwapRGB.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Test and model for IN_OUT semantics

  */
void vglTestInOut(VglImage*  src_dst, float  r, float  g, float  b, float  a){

  vglCheckContext(src_dst, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglTestInOut.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src_dst->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, src_dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "r"), r);
  glUniform1f(glGetUniformLocation(_f, "g"), g);
  glUniform1f(glGetUniformLocation(_f, "b"), b);
  glUniform1f(glGetUniformLocation(_f, "a"), a);

  glViewport(0, 0, 2*src_dst->width, 2*src_dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (src_dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, src_dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(src_dst, VGL_GL_CONTEXT);
}

/** Test and model for IN_OUT semantics, with double output.

  */
void vglTestInOut2(VglImage*  src_dst, VglImage*  dst){

  vglCheckContext(src_dst, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglTestInOut2.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src_dst->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, src_dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT, GL_TEXTURE_2D, dst->tex, 0);
  CHECK_FRAMEBUFFER_STATUS()

  glPushAttrib(GL_VIEWPORT_BIT | GL_COLOR_BUFFER_BIT);
  GLenum buffers[] = { 
    GL_COLOR_ATTACHMENT0_EXT,
    GL_COLOR_ATTACHMENT1_EXT, };
  glDrawBuffers(2, buffers);
  ERRCHECK()


  glViewport(0, 0, 2*src_dst->width, 2*src_dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (src_dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, src_dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glPopAttrib();

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(src_dst, VGL_GL_CONTEXT);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Test and model for multiple input functions.

  */
void vglTestMultiInput(VglImage*  src0, VglImage*  src1, VglImage*  dst, float  weight){

  vglCheckContext(src0, VGL_GL_CONTEXT);

  vglCheckContext(src1, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglTestMultiInput.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src0->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, src1->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler1"),  1);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "weight"), weight);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE2);
  glDisable(GL_TEXTURE_2D);

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Test and model for multiple output functions.

  */
void vglTestMultiOutput(VglImage*  src, VglImage*  dst, VglImage*  dst1){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglTestMultiOutput.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT, GL_TEXTURE_2D, dst1->tex, 0);
  CHECK_FRAMEBUFFER_STATUS()

  glPushAttrib(GL_VIEWPORT_BIT | GL_COLOR_BUFFER_BIT);
  GLenum buffers[] = { 
    GL_COLOR_ATTACHMENT0_EXT,
    GL_COLOR_ATTACHMENT1_EXT, };
  glDrawBuffers(2, buffers);
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  if (dst1->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst1->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glPopAttrib();

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);

  vglSetContext(dst1, VGL_GL_CONTEXT);
}

/** vglDilate

    Dilation of image by 3x3 square structuring element.

  */
void vglTeste(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglTeste.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Return one step of thinning. 
    Algorithm by Bernard and Manzanera 1999.
    Receive as input the image to be thinned and its erosion by a elementary 
cross structuring element.
    Neighborhood pixels are indexed as follows:

\f$
\begin{array}{ccc}

    P3  &  P2  &  P1    \\
    P4  &  P8  &  P0    \\
    P5  &  P6  &  P7

\end{array}
\f$

    References:

    M. Couprie, Note on fifteen 2D parallel thinning algorithms, 2006

    T. M. Bernard and A. Manzanera, Improved low complexity fully parallel
        thinning algorithms, 1999

  */
void vglThinBernardAux(VglImage*  src, VglImage*  eroded, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  vglCheckContext(eroded, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglThinBernardAux.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "src"),  0);
  ERRCHECK()

  glActiveTexture(GL_TEXTURE1);
  glBindTexture(GL_TEXTURE_2D, eroded->tex);
  glUniform1i(glGetUniformLocation(_f, "eroded"),  1);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }

  glActiveTexture(GL_TEXTURE2);
  glDisable(GL_TEXTURE_2D);

  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Return one step of thinning.
    Algorithm by Chin, Wan Stover and Iverson, 1987.
    Receive as input the image to be thinned, buffer image and number 
    of times to iterate.
    Neighborhood pixels are indexed as follows:

\f$ 
\begin{array}{ccccc}

    x   & x   & P10 & x   & x    \\

    x   & P3  & P2  & P1  & x    \\

    P11 & P4  & P0  & P8  & P9   \\

    x   & P5  & P6  & P7  & x    \\

    x   & x   & P12 & x   & x

\end{array}
\f$ 

    References:

    M. Couprie, Note on fifteen 2D parallel thinning algorithms, 2006

    R. T. Chin et al., A one-pass thinning algorithm and its parallel 
        implementation, 1987
  */
void vglThinChinAux(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglThinChinAux.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "src"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Threshold of image. If value is greater than threshold, output is top,
    else, output is 0. Default top value is 1.

  */
void vglThresh(VglImage*  src, VglImage*  dst, float  thresh, float  top){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglThresh.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "thresh"),  thresh);
  glUniform1f(glGetUniformLocation(_f, "top"),  top);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Threshold of image. If value is equal to level, output is top,
    else, output is 0. Default top value is 1.  
    Use after some Distance Transform to get a single distance level set.

  */
void vglThreshLevelSet(VglImage*  src, VglImage*  dst, float  thresh, float  top){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglThreshLevelSet.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "thresh"),  thresh);
  glUniform1f(glGetUniformLocation(_f, "top"),  top);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Flip image vertically i.e. top becomes bottom.

    Image flip done by shader.
  */
void vglVerticalFlip(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglVerticalFlip.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()


  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Finds edge by using a White-Rohrer mask.

  */
void vglWhiteRohrerEdge(VglImage*  src, VglImage*  dst, float  radius){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglWhiteRohrerEdge.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);
  glUniform1f(glGetUniformLocation(_f, "radius"),  radius);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Stores sobel edge filtering in X direction in red channel
    grayscale in y and sobel edge filtering in Y direction in green channel

  */
void vglXGY(VglImage*  src, VglImage*  dst){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglXGY.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform2f(glGetUniformLocation(_f, "tex_size"),  src->ipl->width, src->ipl->height);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

/** Zoom image by factor.

  */
void vglZoom(VglImage*  src, VglImage*  dst, float  factor){

  vglCheckContext(src, VGL_GL_CONTEXT);

  GLint _viewport[4];
  glGetIntegerv(GL_VIEWPORT, _viewport);


  static GLuint _f = 0;
  if (_f == 0){
    printf("FRAGMENT SHADER\n====================\n");
    _f = vglShaderLoad(GL_FRAGMENT_SHADER, (char*) "FS/vglZoom.frag");
    if (!_f){
      printf("%s: %s: Error loading fragment shader.\n", __FILE__, __FUNCTION__);
      exit(1);
   }
  }
  ERRCHECK()

  glUseProgram(_f);

  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src->tex);
  glUniform1i(glGetUniformLocation(_f, "sampler0"),  0);
  ERRCHECK()

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dst->fbo);
  CHECK_FRAMEBUFFER_STATUS()
  ERRCHECK()

  glUniform1f(glGetUniformLocation(_f, "factor"),  factor);

  glViewport(0, 0, 2*dst->width, 2*dst->height);

      glBegin(GL_QUADS);
          glTexCoord2f( 0.0,  0.0);
          glVertex3f ( -1.0, -1.0, 0.0); //Left  Up

          glTexCoord2f( 1.0,  0.0);
          glVertex3f (  0.0, -1.0, 0.0); //Right Up

          glTexCoord2f( 1.0,  1.0);
          glVertex3f (  0.0,  0.0, 0.0); //Right Bottom

          glTexCoord2f( 0.0,  1.0);
          glVertex3f ( -1.0,  0.0, 0.0); //Left  Bottom
      glEnd();

  glUseProgram(0);

  glViewport(_viewport[0], _viewport[1], _viewport[2], _viewport[3]);



  if (dst->has_mipmap){
    glBindTexture(GL_TEXTURE_2D, dst->tex);
    glGenerateMipmapEXT(GL_TEXTURE_2D);
  }
  glActiveTexture(GL_TEXTURE0);

  vglSetContext(dst, VGL_GL_CONTEXT);
}

